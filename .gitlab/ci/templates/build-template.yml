# Modèle de pipeline Docker
# Organise les 3 étapes : build, run et push

##### Upstream variables ##### 
# Les variables suivantes doivent être définies ici OU dans l'appelant
#
#   IMAGENAME:      nom de l'image Docker (et du dossier contenant le code source)
#   TAG:            tag de l'image Docker (par exemple, $CI_COMMIT_SHORT_SHA ou "latest")
#   HOSTPORT:       port exposé sur l'hôte pour accéder au service via Docker
#   CONTAINERPORT:  port exposé dans le container Docker
#   URL_PATH:       URL path pour vérifier que le service est bien démarré (ex: "api/v1/health")
#


include:
  - local: '.gitlab/ci/templates/var-precheck-template.yml'


stages:
  - pre_checks  # importé
  - build
  - run
  - push


# ----------------------------------------------
# Stage 'pre_checks' importé du template
# ----------------------------------------------
upstream_var_checks:
  extends: .var_checks_template
  variables:
    REQUIRED_VARS: "IMAGENAME TAG HOSTPORT CONTAINERPORT URL_PATH"


#----------------------------------------------
# Construire l'image Docker et la taguer
#----------------------------------------------
build_image:
  stage: build
  script:
    - |
      TAG="${TAG:-tag-not-found}" 
      echo "Building with tag: $TAG"
      
      cd $IMAGENAME/
      docker build -t "$CI_REGISTRY_IMAGE/$IMAGENAME:$TAG" .
      
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker tag "$CI_REGISTRY_IMAGE/$IMAGENAME:$TAG" "$CI_REGISTRY_IMAGE/$IMAGENAME:latest"
        docker tag "$CI_REGISTRY_IMAGE/$IMAGENAME:$TAG" "$CI_REGISTRY_IMAGE/$IMAGENAME:$CI_COMMIT_TAG"
      fi

# TAG="${TAG:-tag-not-found}"   # fallback - si TAG est vide alors affecter une valeur de fallback à TAG

# ----------------------------------------------
# Exécuter le container et vérifier qu'il répond
# ----------------------------------------------
run_image:
  stage: run
  
  before_script:
    # si jamais un run manuel a été oublié, alors nettoyer...
    - docker stop $IMAGENAME || true
    - docker rm $IMAGENAME || true
  
  script:
    - |
      TAG="${TAG:-tag-not-found}"
      echo "Running with tag: $TAG"
      
      echo "Image: $IMAGENAME"
      echo "Hostport: $HOSTPORT"
      echo "Containerport: $CONTAINERPORT"
      
      echo "Starting container..."
      echo "docker run --env-file .env -d -p $HOSTPORT:$CONTAINERPORT --name $IMAGENAME $CI_REGISTRY_IMAGE/$IMAGENAME:$TAG"
      docker run --env-file .env -d -p $HOSTPORT:$CONTAINERPORT --name $IMAGENAME "$CI_REGISTRY_IMAGE/$IMAGENAME:$TAG"
      
      echo "sleep 30s to wait for service to start, then check response with cURL"
      sleep 30
      echo "curl -sf -o /dev/null -w \"HTTP Code':' %{http_code}\\n\" http://localhost:$HOSTPORT$URL_PATH"
      curl -sf -o /dev/null -w "HTTP Code':' %{http_code}\n" http://localhost:$HOSTPORT$URL_PATH
  
  after_script:
    # nettoyer après le run
    - docker stop $IMAGENAME || true
    - docker rm $IMAGENAME || true


# ----------------------------------------------
# Pousser l'image Docker vers le registre
# ----------------------------------------------
push_image:
  stage: push

  before_script:
    # s'identifier auprès du registre privé GitLab avant le Push
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin

  script:
    - |
      TAG="${TAG:-tag-not-found}"
      echo "Pushing tag: $TAG"
      docker push "$CI_REGISTRY_IMAGE/$IMAGENAME:$TAG"
    
    # Push également le tag 'latest' si le tag Git du commit est défini
    - |
      if [ ! -z "$CI_COMMIT_TAG" ]; then
        echo "Release TAG detected: pushing tags '$CI_COMMIT_TAG' and 'latest'"
        docker push "$CI_REGISTRY_IMAGE/$IMAGENAME:latest"
        docker push "$CI_REGISTRY_IMAGE/$IMAGENAME:$CI_COMMIT_TAG"
      fi

